# 浏览器工作原理与v8引擎

## 目录

- [浏览器工作原理与v8引擎](#浏览器工作原理与v8引擎)
  - [目录](#目录)
  - [语言特性](#语言特性)
  - [浏览器发展史](#浏览器发展史)
      - [第一浏览器大战](#第一浏览器大战)
      - [第二次浏览器大战](#第二次浏览器大战)
      - [2010年到现在](#2010年到现在)
      - [js语言发展](#js语言发展)
  - [CPU、GPU、内存和多进程](#cpugpu内存和多进程)
  - [浏览器架构](#浏览器架构)
    - [单进程浏览器](#单进程浏览器)
    - [多进程浏览器](#多进程浏览器)
    - [**渲染进程中的线程**](#渲染进程中的线程)
    - [**进程模型（4种进程模型）**](#进程模型4种进程模型)
    - [**进程通信方式**](#进程通信方式)
    - [**多标签通信**](#多标签通信)
  - [输入URL发生了什么](#输入url发生了什么)
      - [ 处理输入](#-处理输入)
      - [开始导航](#开始导航)
      - [读取响应](#读取响应)
      - [查找渲染进程](#查找渲染进程)
      - [确认导航](#确认导航)
      - [额外的步骤](#额外的步骤)
  - [🔶 渲染过程 ](#-渲染过程-)
  - [🔶 V8引擎](#-v8引擎)
      - [**为什么需要js引擎**](#为什么需要js引擎)
      - [**常见的js引擎**](#常见的js引擎)
      - [**webkit内核**](#webkit内核)
      - [**V8引擎**](#v8引擎)

## 语言特性

-   机器语言 01011001指令
-   汇编语言 助记符代替指令
-   高级语言 Java c c++ JavaScript
  
## 浏览器发展史

-   1990年 蒂姆.伯纳斯李发明 world wide web 浏览器，[http://info.cern.ch](http://info.cern.ch "http://info.cern.ch")

#### 第一浏览器大战

-   1993年网景公司，马克安德森和同事开发mosaic浏览器后改名Netscape浏览器，用户广泛使用。
    -   1995年5月livescript诞生，第一个js脚本。
    -   1995年12月网景与sun（Java语音所有者）合作，明明为JavaScript。
-   1996年微软退出IE浏览器捆绑windows操作系统，网景浏览器被挤出市场。
-   1996年网景提交源码内核给国际标准组织ECMA抵抗微软。
    -   1997年ECMA发布标准文件第一版，规定浏览器脚本语言标准并将语言称为ECMAScript。
    -   1998年美国在线公司收购网景业务，gecko内核开放源码。
    -   2003年解散网景，停止开发浏览器。
    -   2001年微软退出windows XP内置IE6，js引擎抽离出来。

#### 第二次浏览器大战

-   1998年网景成立Mozilla基金会，基于gecko内核准备开发新的浏览器
-   2003年苹果公司基于KHTML引擎开发出webkit内核浏览器Safari。
-   2004年Mozilla发布全新浏览器Firefox。
-   2005年苹果开源webkit内核。
-   2008年谷歌基于苹果的webkit内核开发chromium内核的Chrome浏览器，推出v8引擎，nodejs基于v8得到发展，前端工程化发展的开端。

Mozilla的火狐、Chrome、IE浏览器三足鼎立。

#### 2010年到现在

-   2013年谷歌与webkit分离，基于chromium项目开发blink引擎。
-   2015年window10发布，微软推出全新浏览器Microsoft Edge取代IE。
-   2017年Mozilla全新的打造的 [Quantum](https://link.juejin.cn/?target=https://en.wikipedia.org/wiki/Quantum_\(Mozilla\) "Quantum") 版本
-   目前Chrome占据绝对优势。

#### js语言发展

-   1995年Brendan Eich只用了10天完成语言设计，语法来源
    1.  基本语法：借鉴 C 语言和 Java 语言。
    2.  数据结构：借鉴 Java 语言，包括将值分成原始值和对象两大类。
    3.  函数的用法：借鉴 Scheme 语言和 Awk 语言，将函数当作第一等公民，并引入闭包。
    4.  原型继承模型：借鉴 Self 语言（Smalltalk 的一种变种）。
    5.  正则表达式：借鉴 Perl 语言。
    6.  字符串和数组处理：借鉴 Python 语言。
-   1997年7月，ECMAScript 1.0发布
-   1998年6月，ECMAScript 2.0版发布。
-   1999年12月，ECMAScript 3.0版发布，成为 JavaScript 的通行标准，得到了广泛支持。
-   2009年12月，ECMAScript 5.0版 正式发布。
-   2015年6月，ECMAScript 6 正式发布，并且更名为“ECMAScript 2015”。
-   TC39委员会计划每年发布一个版本，命名按照ECMAScript年份。

## CPU、GPU、内存和多进程

-   进程：看成正在执行的程序，CPU资源分配的最小单位
-   线程：CPU调度的最小单位
    -   进程可以类比为工厂，线程就是工厂里面的工人，一个工厂可以包含一个或者多个工人，工人之间可以相互协作，并且共享工作空间
    -   启动应用会至少创建一个进程，操作系统会为进程分配一块内存，所有数据状态都保存在内存中，还会创建多个线程辅助工作，共享这部分内存，关闭应用进程被终结，操作系统释放相关内存，内存中数据消失。
        还有创建其他进程完成不同任务，会分配新的内存，两个进程之间可以使用IPC （Inter Process Communication）进行通信。

## 浏览器架构

### 单进程浏览器

-   不稳定
    -   其中一个线程卡死，可能会导致整个程序出问题，比如打开多个标签页，其中一个标签页卡死可能会导致整个浏览器无法正常运行
    -   码或插件崩溃导致整个浏览器崩溃
-   不流畅
    -   浏览器一个进程里是可以共享数据的，那JS线程岂不是可以随意访问浏览器进程内的所有数据，这显然不合理
    -   比如内存泄漏整个浏览器卡死，不管是不是当前tab页面。
-   不安全
    -   一个进程需要负责太多事情，会导致运行效率问题
    -   一个运行页面，插件携带病毒，泄漏账号密码，没有隔离。

### 多进程浏览器

-   浏览器进程
    -   &#x20;负责控制浏览器除标签页外的界面，包括地址栏、书签、前进后退按钮等，以及负责与其他进程的协调工作，同时提供存储功能
-   GPU进程
    -   责整个浏览器界面的渲染。Chrome刚开始发布的时候是没有GPU进程的，而使用GPU的初衷是为了实现3D CSS效果，只是后面网页、Chrome的UI界面都用GPU来绘制，这使GPU成为浏览器普遍的需求，最后Chrome在多进程架构上也引入了GPU进程
-   网络进程
    -   负责发起和接受网络请求，以前是作为模块运行在浏览器进程一时在面的，后面才独立出来，成为一个单独的进程
-   插件进程
    -   主要是负责插件的运行，因为插件可能崩溃，所以需要通过插件进程来隔离，以保证插件崩溃也不会对浏览器和页面造成影响
-   渲染进程
    -   负责控制显示tab标签页内的所有内容，核心任务是将HTML、CSS、JS转为用户可以与之交互的网页，排版引擎Blink和JS引擎V8都是运行在该进程中，默认情况下Chrome会为每个Tab标签页创建一个渲染进程
-   优点：
    -   某一渲染进程出问题不会影响其他进程
    -   为安全，在系统层面上限定了不同进程的权限
-   缺点：
    -   由于不同进程间的内存不共享，不同进程的内存常常需要包含相同的内容。

### **渲染进程中的线程**

-   GUI渲染线程
    -   负责渲染页面，解析html和CSS、构建DOM树、CSSOM树、渲染树、和绘制页面，重绘重排也是在该线程执行
-   JS引擎线程
    -   一个tab页中只有一个JS引擎线程(单线程)，负责解析和执行JS。它GUI渲染进程不能同时执行，只能一个一个来，如果JS执行过长就会导致阻塞掉帧
-   计时器线程
    -   指setInterval和setTimeout，因为JS引擎是单线程的，所以如果处于阻塞状态，那么计时器就会不准了，所以需要单独的线程来负责计时器工作
-   异步http请求线程
    -   XMLHttpRequest连接后浏览器开的一个线程，比如请求有回调函数，异步线程就会将回调函数加入事件队列，等待JS引擎空闲执行
-   事件触发线程
    -   主要用来控制事件循环，比如JS执行遇到计时器，AJAX异步请求等，就会将对应任务添加到事件触发线程中，在对应事件符合触发条件触发时，就把事件添加到待处理队列的队尾，等JS引擎处理

### **进程模型（4种进程模型）**

-   Process-per-site-instance：默认模式。访问不同站点创建新的进程，在旧页面中打开的新页面，且新页面与旧页面属于同一站点的话会共用一个进程不会创建
-   Process-per-site：同一站点使用同一进程
-   Process-per-tab：每一个标签页都创建新的进程
-   Single Process：单进程模式

### **进程通信方式**

-   管道通信
    -   就是操作系统在内核中开辟一段缓冲区，进程1可以将需要交互的数据拷贝到这个缓冲区里，进程2就可以读取了
-   消息队列通信
    -   消息队列就是用户可以添加和读取消息的列表，消息队列里提供了一种从一个进程向另一个进程发送数据块的方法，不过和管道通信一样每个数据块有最大长度限制
-   共享内存通信
    -   就是映射一段能被其他进程访问的内存，由一个进程创建，但多个进程都可以访问，共享进程最快的是IPC方式
-   信号量通信
    -   比如信号量初始值是1，进程1来访问一块内存的时候，就把信号量设为0，然后进程2也来访问的时候看到信号量为0，就知道有其他进程在访问了，就不访问了
-   socket
    -   其他的都是同一台主机之间的进程通信，而在不同主机的进程通信就要用到socket的通信方式了，比如发起http请求，服务器返回数据

### **多标签通信**

-   localStorage
    -   在一个标签页监听localStorage的变化，然后当另一个标签页修改的时候，可以通过监听获取新数据
-   WebSocket
    -   因为websocket可以实现实时服务器推送，所以服务器就可以来当这个中介者。标签页通过向服务器发送数据，然后服务器再向其他标签推送转发
-   ShareWorker
    -   会在页面的生命周期内创建一个唯一的线程，并开启多个页面也只会使用同一个线程，标签页共享一个线程
-   postMessage：
    ```javascript
    // 发送方

     window.parent().pastMessage('发送的数据','http://接收的址')

     // 接收方

     window.addEventListener('message',(e)=>{ let data = e.data })
    ```

## 输入URL发生了什么

#### &#x20;处理输入

-   UI线程判断用户输入的是URL还是查询

#### 开始导航

1.  点击回车UI thread 通知 network thread 获取网页内容，并控制 tab 上的 spinner 展现，表示正在加载中。network thread 会执行 DNS 查询，随后为请求建立 TLS 连接
2.  如果 network thread 接收到了重定向请求头如 301，network thread 会通知 UI thread 服务器要求重定向，之后，另外一个 URL 请求会被触发。

#### 读取响应

1.  当请求响应返回的时候，network thread 会依据 Content-Type 及 MIME Type sniffing 判断响应内容的格式
2.  如果响应内容的格式是 HTML ，下一步将会把这些数据传递给 renderer process，如果是 zip 文件或者其它文件，会把相关数据传输给下载管理器。
3.  Safe Browsing 检查也会在此时触发，如果域名或者请求内容匹配到已知的恶意站点，network thread 会展示一个警告页。此外 CORB 检测也会触发确保敏感数据不会被传递给渲染进程。

#### 查找渲染进程

1.  当上述所有检查完成，network thread 确信浏览器可以导航到请求网页，network thread 会通知 UI thread 数据已经准备好，UI thread 会查找到一个 renderer process 进行网页的渲染。

#### 确认导航

1.  进过了上述过程，数据以及渲染进程都可用了， Browser Process 会给 renderer process 发送 IPC 消息来确认导航，一旦 Browser Process 收到 renderer process 的渲染确认消息，导航过程结束，页面加载过程开始。
2.  此时，地址栏会更新，展示出新页面的网页信息。history tab 会更新，可通过返回键返回导航来的页面，为了让关闭 tab 或者窗口后便于恢复，这些信息会存放在硬盘中。
3.  Browser Process 和 Renderer Process 通过 IPC 通信，请求 Renderer Process 渲染页面

#### 额外的步骤

1.  一旦导航被确认，renderer process 会使用相关的资源渲染页面，下文中我们将重点介绍渲染流程。当 renderer process 渲染结束（渲染结束意味着该页面内的所有的页面，包括所有 iframe 都触发了 onload 时），会发送 IPC 信号到 Browser process， UI thread 会停止展示 tab 中的 spinner。
2.  Renderer Process 发送 IPC 消息通知 browser process 页面已经加载完成
3.  浏览器进程在收到“确认提交”的消息后，会更新浏览器界面状态，包括了安全状态、地址栏的URL、前进后退的历史状态，并更新Web页面。

> **浏览器内核既是渲染引擎（layout engineer或Rendering Engine）或者排版引擎和js引擎**。

## 🔶 渲染过程&#x20;

主要职责：渲染进程几乎负责 Tab 内的所有事情，渲染进程的核心目的在于转换 HTML CSS JS 为用户可交互的 web 页面。

**渲染进程中主要包含以下线程：**

-   主线程 Main thread
    -   主线程中即可以执行 JS ，也可以执行渲染工作，还可以执行其他工作，但是由于是主线程是只是一个线程，所以各个工作不能同时执行，只能按照一定的先后次序执行。
-   工作线程 Worker thread
    -   由 Worker 或 Service Worker 注册的 javascript 代码会有单独的 Worker 线程处理，独立于主线程。
-   排版线程 Compositor thread
    -   页面平滑层次展示
-   光栅线程 Raster thread
    -   页面快速呈现

**总结：**

1.  将HTML内容构建成DOM树。

-   html parser解析：
    1.  &#x20;① 开始标签 ② 结束标签 ③ 自封闭标签 解析html标签
    2.  解析完成都会生成对应的token，另外会解析文本、属性等也会与对应的token
    3.  每个token都有对应的type，文本就是text，开始标签就是startTag，结束标签就是endTag，最后使用token组合构建dom
        [实战中学习浏览器工作原理 — HTML 解析与 CSS 计算](https://xie.infoq.cn/article/6a511f0ebdb6e555a5438c2fe "实战中学习浏览器工作原理 — HTML 解析与 CSS 计算")
    AST语法树 [https://astexplorer.net/](https://astexplorer.net/ "https://astexplorer.net/")
-   遇到css或者js标签
    1.  遇到js暂停解析HTML，从缓存中或者网络中去加载资源。

1.  将CSS内容构建成CSSOM树。
    1.  样式表 style link line 浏览器默认样式表
    2.  document.styleSheets\[0] 所有样式表，document.styleSheets\[0].addRule('div',"border: 1px solid #f60 !important")
        [https://www.51cto.com/article/717431.html](https://www.51cto.com/article/717431.html "https://www.51cto.com/article/717431.html")
2.  将DOM 树和 CSSOM 树合成渲染树。
3.  根据渲染树进行页面元素的布局。
4.  对渲染树进行分层操作，并生成分层树。
5.  为每个图层生成绘制列表，并提交到合成线程。
6.  合成线程将图层分成不同的图块，并通过栅格化将图块转化为位图。
7.  合成线程给浏览器进程发送绘制图块指令。
8.  浏览器进程会生成页面，并显示在屏幕上。

[浏览器默认样式](https://github.com/chromium/chromium/blob/main/third_party/blink/renderer/core/html/resources/html.css "浏览器默认样式")

body 默认样式 margin：8px

```css
base, basefont, datalist, head, link, meta, noembed,

 noframes, param, rp, script, style, template, title {

 display: none;

 }
```

**重排（回流）**

当我们的操作引发了 DOM 树中几何尺寸的变化（改变元素的大小、位置、布局方式等），这时渲染树里有改动的节点和它影响的节点都要重新计算。这个过程就叫做重排，也称为回流。在改动发生时，要重新经历页面渲染的整个流程，所以开销是很大的。

以下操作都会导致页面重排：

-   页面首次渲染。
-   浏览器窗口大小发生变化。
-   元素的内容发生变化。
-   元素的尺寸或者位置发生变化。
-   元素的字体大小发生变化。
-   激活CSS伪类。
-   查询某些属性或者调用某些方法。
-   添加或者删除可见的DOM元素。

在触发重排时，由于浏览器渲染页面是基于流式布局的，所以当触发回流时，会导致周围的DOM元素重新排列，它的影响范围有两种：

-   全局范围：从根节点开始，对整个渲染树进行重新布局。
-   局部范围：对渲染树的某部分或者一个渲染对象进行重新布局。

**重绘**

当对 DOM 的修改导致了样式的变化、但未影响其几何属性（比如修改颜色、背景色）时，浏览器不需重新计算元素的几何属性、直接为该元素绘制新的样式（会跳过重排环节），这个过程叫做重绘。简单来说，重绘是由对元素绘制属性的修改引发的。

当我们修改元素绘制属性时，页面布局阶段不会执行，因为并没有引起几何位置的变换，所以就直接进入了绘制阶段，然后执行之后的一系列子阶段。相较于重排操作，重绘省去了布局和分层阶段，所以执行效率会比重排操作要高一些。

**注意：** 当触发重排时，一定会触发重绘，但是重绘不一定会引发重排。

-   每个tab都有独立的渲染进程
-   每个iframe都是独立的渲染进程
-   chrome右上角菜单-更多-任务管理器查看更多进程

console.`dir`（document）输出dom对象

## 🔶 V8引擎

#### **为什么需要js引擎**

js代码最终需要转换为机器CPU识别的代码011001等，那就需要js引擎处理。

#### **常见的js引擎**

-   SpiderMonkey：第一款JavaScript引擎，由Brendan Eich开发（也就是JavaScript作者）；
-   Chakra：微软开发，用于IT浏览器；
-   JavaScriptCore：WebKit中的JavaScript引擎，Apple公司开发；
-   V8：Google开发的强大JavaScript引擎，也帮助Chrome从众多浏览器中脱颖而出；

#### **webkit内核**

事实上WebKit内核由两部分组成的：

-   WebCore：负责HTML解析、布局、渲染等等相关的工作;
-   JavaScriptCore：解析、执行JavaScript代码(JavaScript引擎的工作);

#### **V8引擎**

-   支持语言：V8是用C ++编写的Google开源高性能JavaScript和WebAssembly引擎，它用于Chrome和Node.js等;
    -   V8可以运行JavaScript和WebAssembly引擎编译的汇编语言等
-   跨平台：它实现ECMAScript和WebAssembly，并在Windows 7或更高版本，macOS 10.12+和使用x64，IA-32，

ARM或MIPS处理器的Linux系统上运行;

-   嵌入式：V8可以独立运行，也可以嵌入到任何C ++应用程序中;

> **AST语法树**
>
> [Babel & AST（抽象语法树）](https://juejin.cn/post/7045496002614132766 "Babel & AST（抽象语法树）")

Parse模块会将JavaScript代码转换成AST(抽象语法树)，这是因为解释器并不直接认识JavaScript代码;

-   如果函数没有被调用，那么是不会被转换成AST的;
-   Parse的V8官方文档：[https://v8.dev/blog/scanner](https://v8.dev/blog/scanner "https://v8.dev/blog/scanner")
-

Ignition是一个解释器，会将AST转换成ByteCode(字节码);

-   同时会收集TurboFan优化所需要的信息(比如函数参数的类型信息，有了类型才能进行真实的运算);
-   如果函数只调用一次，Ignition会执行解释执行ByteCode;
-   Ignition的V8官方文档：[https://v8.dev/blog/ignition-interpreter](https://v8.dev/blog/ignition-interpreter "https://v8.dev/blog/ignition-interpreter")

TurboFan是一个编译器，可以将字节码编译为CPU可以直接执行的机器码;

-   如果一个函数被多次调用，那么就会被标记为热点函数，那么就会经过TurboFan转换成优化的机器码，提高代码的执行性能;
-   但是，机器码实际上也会被还原为ByteCode，这是因为如果后续执行函数的过程中，类型发生了变化(比如sum函数原来执行的是number类型，后来执行变成了string类型)，之前优化的机器码并不能正确的处理运算，就会逆向的转换成字节码;
-   TurboFan的V8官方文档：[https://v8.dev/blog/turbofan-jit](https://v8.dev/blog/turbofan-jit "https://v8.dev/blog/turbofan-jit")

上面是JavaScript代码的执行过程，事实上V8的内存回收也是其强大的另外一个原因;

-   Orinoco模块，负责垃圾回收，将程序中不需要的内存回收;
-   Orinoco的V8官方文档：[https://v8.dev/blog/trash-talk](https://v8.dev/blog/trash-talk "https://v8.dev/blog/trash-talk")
-   关于V8引擎的垃圾内存回收机制，可以看下我之前整理的这篇文章「经典升华」V8引擎的垃圾内存回收机制

V8引擎本身的源码结构非常复杂，大概有超过100w行C++代码，通过了解它的架构，我们可以知道它是如何对JavaScript执行的：

-   `Parse模块`会将JavaScript代码转换成`AST(抽象语法树)`，这是因为解释器并不直接认识JavaScript代码;如果函数没有被调用，那么是不会被转换成AST的
-   `Ignition`是一个解释器，会将`AST`转换成`ByteCode(字节码)`,同时会收集`TurboFan`优化所需要的信息(比如函数参数的类型信息，有了类型才能进行真实的运算);
-   `TurboFan`是一个编译器，可以将字节码编译为CPU可以直接执行的机器码; 如果一个函数被多次调用，那么就会被标记为热点函数，那么就会经过`TurboFan`转换成优化的机器码，提高代码的执行性能
-   但是，当优化的代码的变量类型发生变化时，字节码还是会转换成机械码的，比如如下的代码

```typescript
function sum(a,b) {
    return a+b
}
sum(1,2) // Number类型的数据
sum(2,3) // Number类型的数据
sum(2,2) // Number类型的数据

// 我们这个sum函数的参数一直是两个Number类型的数据相加，这个函数就会被标记为热点函数，就会经过`TurboFan`转换成优化的机器码

 sum(2,'777') // Number类型的数据和字符串相加
// 但是当string类型和 Number类型相加时，之前优化的机器码并不能正确的处理运算，就会逆向的转换成字节码

```

[图解浏览器](https://zhuanlan.zhihu.com/p/47407398 "图解浏览器")

[现代浏览器原理](https://blog.csdn.net/weixin_45792953/article/details/120685545 "现代浏览器原理")

[深入理解浏览器中的进程与线程](https://segmentfault.com/a/1190000040765165 "深入理解浏览器中的进程与线程")

Parse模块会将JavaScript代码转换成AST(抽象语法树)，这是因为解释器并不直接认识JavaScript代码;

如果函数没有被调用，那么是不会被转换成AST的;
Parse的V8官方文档：[https://v8.dev/blog/scanner](https://v8.dev/blog/scanner "https://v8.dev/blog/scanner")
Ignition是一个解释器，会将AST转换成ByteCode(字节码);

同时会收集TurboFan优化所需要的信息(比如函数参数的类型信息，有了类型才能进行真实的运算);
如果函数只调用一次，Ignition会执行解释执行ByteCode;
Ignition的V8官方文档：[https://v8.dev/blog/ignition-interpreter](https://v8.dev/blog/ignition-interpreter "https://v8.dev/blog/ignition-interpreter")
TurboFan是一个编译器，可以将字节码编译为CPU可以直接执行的机器码;

如果一个函数被多次调用，那么就会被标记为热点函数，那么就会经过TurboFan转换成优化的机器码，提高代码的执行性能;
但是，机器码实际上也会被还原为ByteCode，这是因为如果后续执行函数的过程中，类型发生了变化(比如sum函数原来执行的是number类型，后来执行变成了string类型)，之前优化的机器码并不能正确的处理运算，就会逆向的转换成字节码;
TurboFan的V8官方文档：[https://v8.dev/blog/turbofan-jit](https://v8.dev/blog/turbofan-jit "https://v8.dev/blog/turbofan-jit")
上面是JavaScript代码的执行过程，事实上V8的内存回收也是其强大的另外一个原因;

Orinoco模块，负责垃圾回收，将程序中不需要的内存回收;
Orinoco的V8官方文档：[https://v8.dev/blog/trash-talk](https://v8.dev/blog/trash-talk "https://v8.dev/blog/trash-talk")
关于V8引擎的垃圾内存回收机制，可以看下我之前整理的这篇文章「经典升华」V8引擎的垃圾内存回收机制
编程语言会大体分为两大类：

解释型语言：运行效率相对较低(比如JavaScript)
编译型语言：运行效率相对较高(比如C++)
上述情况对应的是JavaScript解释性语言的大体执行流程，但编译性语言往往不是，比如C++，例如系统内的某些应用程序用C++编写的，它们在执行的时候会直接转化为机器语言(二进制格式010101)，并交给CPU统一执行，这样的运行效率自然相对较高了些。

但V8也对解释性的编程语言做了一个优化，就是上文提到的TurboFan优化编译器，如果一个JavaScript函数被多次调用，那么它就会经过TurboFan抓成优化后的机器码，交由CPU执行，提高代码的执行性能。

Parse模块会将JavaScript代码转换成AST(抽象语法树)，这是因为解释器并不直接认识JavaScript代码;

如果函数没有被调用，那么是不会被转换成AST的;
Parse的V8官方文档：[https://v8.dev/blog/scanner](https://v8.dev/blog/scanner "https://v8.dev/blog/scanner")
Ignition是一个解释器，会将AST转换成ByteCode(字节码);

同时会收集TurboFan优化所需要的信息(比如函数参数的类型信息，有了类型才能进行真实的运算);
如果函数只调用一次，Ignition会执行解释执行ByteCode;
Ignition的V8官方文档：[https://v8.dev/blog/ignition-interpreter](https://v8.dev/blog/ignition-interpreter "https://v8.dev/blog/ignition-interpreter")
TurboFan是一个编译器，可以将字节码编译为CPU可以直接执行的机器码;

如果一个函数被多次调用，那么就会被标记为热点函数，那么就会经过TurboFan转换成优化的机器码，提高代码的执行性能;
但是，机器码实际上也会被还原为ByteCode，这是因为如果后续执行函数的过程中，类型发生了变化(比如sum函数原来执行的是number类型，后来执行变成了string类型)，之前优化的机器码并不能正确的处理运算，就会逆向的转换成字节码;
TurboFan的V8官方文档：[https://v8.dev/blog/turbofan-jit](https://v8.dev/blog/turbofan-jit "https://v8.dev/blog/turbofan-jit")
上面是JavaScript代码的执行过程，事实上V8的内存回收也是其强大的另外一个原因;

Orinoco模块，负责垃圾回收，将程序中不需要的内存回收;
Orinoco的V8官方文档：[https://v8.dev/blog/trash-talk](https://v8.dev/blog/trash-talk "https://v8.dev/blog/trash-talk")
关于V8引擎的垃圾内存回收机制，可以看下我之前整理的这篇文章「经典升华」V8引擎的垃圾内存回收机制
编程语言会大体分为两大类：

解释型语言：运行效率相对较低(比如JavaScript)
编译型语言：运行效率相对较高(比如C++)
上述情况对应的是JavaScript解释性语言的大体执行流程，但编译性语言往往不是，比如C++，例如系统内的某些应用程序用C++编写的，它们在执行的时候会直接转化为机器语言(二进制格式010101)，并交给CPU统一执行，这样的运行效率自然相对较高了些。

但V8也对解释性的编程语言做了一个优化，就是上文提到的TurboFan优化编译器，如果一个JavaScript函数被多次调用，那么它就会经过TurboFan抓成优化后的机器码，交由CPU执行，提高代码的执行性能。
